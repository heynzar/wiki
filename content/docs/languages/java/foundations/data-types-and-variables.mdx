---
title: Data Types & Variables
description: Your first document
icon: FileText
---

---

# Data Types & Variables: Primitive vs Reference [!toc]

## The Foundation

**What Are Variables** -> A variable is a container that stores information.

```java
int age = 25;
```

Here, `age` is a variable. It holds the number `25`.

**What Are Data Types** -> Data types tell Java what kind of information a variable can store. Think of it like a label that tells the computer whether the value is a number, text, true/false, and so on.

In the example above, `int` is the data type. It stands for `integer`, which simply means a **number**.

But here's where Java gets interesting: **Different types of data are stored differently in memory.**

Java has two main categories of data types:

- **Primitive types**
- **Reference types**

Understanding the difference is important, it affects how your code works, how memory is used, and where certain bugs can appear.

---

## Why Types, Anyway?

You might notice that some programming languages don't require you to declare data types at all (like JavaScript or Python).

In this explanation, we'll use Python as our example, but the idea is the same for both. What we're really comparing here are two different philosophies in the programming-language world: languages that enforce explicit types (like Java) and languages that handle types dynamically (like Python).

Each approach shapes how you write code, how errors are caught, and how programs run.

### Static vs Dynamic Typing

**Java (Static Typing):**

```java
int age = 25;  // Must declare type (int). Compiler knows it's an (int = integer).
age = "hello"; // COMPILE ERROR - can't assign string to int
```

**Python (Dynamic Typing):**

```python
age = 25       # Could be anything
age = "hello"  # Fine, now it's a string
age = 3.14     # Fine, now it's a float
```

### Safety vs Flexibility

**Java's Approach (Static, Typed) -> Safety:**

-> **Advantages:**

- Catches errors at compile time (before running)
- Faster execution (compiler optimizes for known types)
- Clear documentation (code shows what types exist)
- Better for large teams (explicit types prevent mistakes)
- IDE can help better (knows exact types)

-> **Disadvantages:**

- More code to write
- Slower to prototype (need to declare everything)
- Less flexible (can't change types on the fly)

**Python's Approach (Dynamic, Not Typed) -> Flexibility:**

-> **Advantages:**

- Less verbose (quick to write)
- More flexible (types can change)
- Faster to prototype (fewer lines)

-> **Disadvantages:**

- Errors caught at runtime (program crashes mid-execution)
- Slower execution (runtime must check types constantly)
- Less clear (what type is this variable?)
- Easy to make mistakes (typos discovered too late)

### Why Big Companies Still Use Java [!toc]

Netflix, Google, Amazon, banks, they use Java specifically because of static typing.

Why? **Safety at scale.**

When you have: 1 million lines of code, 500 developers and systems handling billions of dollars

You want a compiler to catch mistakes before they happen. Python's flexibility becomes a liability. Type errors that would crash production systems get caught during compilation in Java.

Java's data types aren't a limitation. They're a feature that prevents entire categories of bugs. And this difference is exactly why TypeScript was created, to bring optional typing to JavaScript.

---

## Primitive Types: Simple Values

Primitive types store simple values directly. The value is stored in the **variable itself**.

### The Eight Primitive Types [!toc]

Java has exactly eight primitive types:

```java
// Integer types (whole numbers)
byte age = 5;              // 8-bit: -128 to 127
short population = 5000;   // 16-bit: -32,768 to 32,767
int score = 100;           // 32-bit: -2.1B to 2.1B (most common)
long distance = 1000000L;  // 64-bit: huge numbers (add 'L' at end)

// Floating-point types (decimals)
float price = 19.99f;      // 32-bit (add 'f' at end)
double salary = 50000.00;  // 64-bit (most common for decimals)

// Other types
boolean isActive = true;   // true or false only
char letter = 'A';         // single character (use single quotes)
```

**Quick reference:**

| Type      | Size   | Range                       | Usage                        |
| --------- | ------ | --------------------------- | ---------------------------- |
| `byte`    | 8-bit  | -128 to 127                 | Rarely used                  |
| `short`   | 16-bit | -32,768 to 32,767           | Rarely used                  |
| `int`     | 32-bit | -2.1 billion to 2.1 billion | **Most common for integers** |
| `long`    | 64-bit | Huge range                  | When `int` isn't big enough  |
| `float`   | 32-bit | Decimals (less precise)     | Rarely used                  |
| `double`  | 64-bit | Decimals (more precise)     | **Most common for decimals** |
| `boolean` | 1-bit  | `true` or `false`           | Conditions, flags            |
| `char`    | 16-bit | Single character            | Single letters, symbols      |

**Simple Rule:**

- **Integers** -> Use `int` (unless you need huge numbers, then `long`)
- **Decimals** -> Use `double` (unless memory is critical, then `float`)
- **True/False** -> Use `boolean`
- **Single character** -> Use `char`

---

## Reference Types: Objects

Reference types are different. They don't store the actual value, they store a reference (an address in memory) that points to an object.

**But what is an object?** -> An object is a bundle of data and behaviors grouped together. You can think of an object like a folder that contains both data and tools.

When you create an object:

```java
String name = "Alice";
```

Here, `name` does not hold the text directly. <br />
Instead, it holds a **reference** to a String object that contains the text `"Alice"`.

Java:

1. Creates an object somewhere in memory
2. Stores the actual "Alice" text in that memory
3. Stores the _address_ of that memory in the variable `name`

```
Variable name: name
Memory address: 2000
Value stored: 4000 (address pointing to "Alice")
        ↓
    Actual object "Alice" stored at address 4000
```

### Common Reference Types [!toc]

**String (text):**

```java
String greeting = "Hello, World!";
String name = "Alice";
```

**Arrays (collections of values):**

```java
int[] scores = {95, 87, 92};
String[] names = {"Alice", "Bob", "Charlie"};
```

**Data Structures (collections for dynamic data):**

```java
ArrayList<String> names = new ArrayList();  // List that grows/shrinks
HashMap<String, Integer> scores = new HashMap();  // Key-value pairs
```

**Objects (instances of classes):**

```java
Scanner scanner = new Scanner(System.in);
ArrayList list = new ArrayList();
```

**Note on Data Structures:** Arrays and collections (ArrayList, HashMap, etc.) are built using reference types. They store references to multiple objects. We'll dive deep into these in later chapters. For now, just know that they're reference types, changes to them affect all variables pointing to them.

---

## How Java Stores Data in Memory

This is crucial to understand. It's the difference between Java and languages like C/C++.

### The Two Memory Regions: Stack vs Heap [!toc]

Java divides memory into two regions:

**Stack (Fast, Limited):**

- Stores primitive values
- Stores references (addresses) to objects
- Automatically cleaned up
- Small, organized, efficient

**Heap (Slower, Larger):**

- Stores all objects
- Larger space
- Manual cleanup in C/C++, automatic in Java
- Disorganized, but flexible

### Visual Example [!toc]

```java
int age = 25;
String name = "Alice";
ArrayList<Integer> scores = new ArrayList();
scores.add(95);
```

**Memory layout:**

```
STACK (fast, organized)
┌─────────────────────┐
│ age: 25             │ (primitive: value stored directly)
├─────────────────────┤
│ name: [address 5000]│ (reference: stores address)
├─────────────────────┤
│ scores: [addr 6000] │ (reference: stores address)
└─────────────────────┘

HEAP (slower, larger)
┌─────────────────────┐
│ (5000) "Alice"      │ (String object)
├─────────────────────┤
│ (6000) ArrayList    │ (ArrayList object)
│        [95]         │ (contains values)
└─────────────────────┘
```

### Key Points [!toc]

1. **Primitives live on stack** -> The value is right there
2. **References live on stack** -> The address is right there
3. **Objects live on heap** -> The actual data is there
4. **Stack is fast** -> Accessing primitives is instant
5. **Heap is slower** -> Following an address takes extra work

### Why Does This Matter? [!toc]

- **For performance:** Primitives are faster. If speed matters, use `int` instead of `Integer` (object wrapper).
- **For memory:** Objects on heap can be large. Thousands of objects use significant memory.
- **For behavior:** Understanding this prevents reference bugs (modifying one variable affecting another).

---

## Java vs C/C++: Why Java Removed Pointers

You might have heard of "pointers" in C/C++. Java deliberately removed them. Here's why.

### What Are Pointers? (C/C++)

In C/C++, you manually work with memory addresses:

```c
// C/C++ example
int age = 25;
int* ptr = &age;  // ptr is a pointer to age's address
*ptr = 30;        // Dereference: change the value through pointer
```

Pointers are powerful but dangerous.

### The Problem with Manual Pointers [!toc]

**Pointer bugs in C/C++:**

```c
// Bug 1: Null pointer
int* ptr = NULL;
*ptr = 5;  // CRASH - accessing nothing

// Bug 2: Dangling pointer
int* ptr = malloc(sizeof(int));
free(ptr);
*ptr = 5;  // CRASH - pointing to freed memory

// Bug 3: Memory leak
int* ptr = malloc(sizeof(int));
// Forgot to free(ptr)... memory lost forever

// Bug 4: Pointer arithmetic errors
int arr[5];
int* ptr = arr;
ptr = ptr + 1000;  // Pointing to random memory
*ptr = 5;  // CRASH or corruption
```

These bugs are catastrophic and hard to find.

### Java's Solution: Automatic Reference Management [!toc]

Java kept references but removed manual pointer arithmetic:

```java
// Java: safe references
String name = null;  // Can be null, but safe
name = "Alice";      // Now points to object
// Automatic cleanup: when no variables point to it, garbage collector removes it
```

**What Java does:**

1. **Hidden references** - You work with references, but Java hides the complexity
2. **No arithmetic** - Can't do `ptr + 1000` nonsense
3. **Automatic cleanup** - Garbage collector removes unused objects
4. **Null safety** - You can check `if (name != null)` safely

### Comparison: C/C++ vs Java [!toc]

| Aspect               | C/C++                         | Java                                 |
| -------------------- | ----------------------------- | ------------------------------------ |
| Pointers             | Manual, explicit              | Automatic, hidden as references      |
| Memory allocation    | Manual `malloc`/`new`         | Automatic `new`                      |
| Memory deallocation  | Manual `free`/`delete`        | Automatic garbage collection         |
| Null pointer bugs    | Common, hard to debug         | Rare, caught by compiler             |
| Memory leaks         | Very easy to cause            | Nearly impossible                    |
| Performance overhead | None                          | Garbage collector adds tiny overhead |
| Developer time       | Spend debugging memory issues | Spend building features              |

### Real Cost: Time and Bugs [!toc]

**C/C++ developer:**

- Spends 40% time managing memory
- Spends 30% time debugging memory bugs
- Spends 30% time building features

**Java developer:**

- Spends 0% time managing memory
- Spends 5% time debugging null pointers
- Spends 95% time building features

This is why enterprise systems (banks, healthcare, government) use Java. Not for performance, but for reliability and developer productivity.

### The Trade-off [!toc]

Java's automatic memory management costs slightly more CPU and RAM (garbage collector runs periodically). But the benefit: fewer bugs, faster development, more reliable systems, is worth it for almost all use cases.

---

## Primitive vs Reference: The Key Differences

This is the most important section. Really understand this.

### Difference 1: Storage [!toc]

**Primitives store values directly:**

```java
int x = 5;
int y = x;  // y gets a copy of the value
y = 10;
System.out.println(x);  // Still 5 (unchanged)
System.out.println(y);  // Now 10
```

Both `x` and `y` have their own copies of values.

**References store addresses:**

```java
ArrayList list1 = new ArrayList();
list1.add("Apple");

ArrayList list2 = list1;  // list2 points to the SAME object
list2.add("Banana");

System.out.println(list1);  // ["Apple", "Banana"] - CHANGED!
System.out.println(list2);  // ["Apple", "Banana"] - same object
```

Both variables point to the same object. Modifying through one variable affects the other.

**Visual comparison:**

```
PRIMITIVE:
int x = 5        int y = x
├─ x: [5]        ├─ y: [5]  (separate copy)

REFERENCE:
ArrayList list1        ArrayList list2 = list1
├─ list1: [address 1000] ─┐
                            └──> [Apple, Banana]
├─ list2: [address 1000] ─┘     (same object)
```

### Difference 2: Null Values [!toc]

**Primitives can never be null:**

```java
int x = null;  // COMPILE ERROR - primitives can't be null
```

**References can be null (not pointing to anything):**

```java
String name = null;  // Valid - name points to nothing
ArrayList list = null;  // Valid - list points to nothing

System.out.println(name.length());  // RUNTIME ERROR - NullPointerException
```

This is a common bug. Check for null first.

### Difference 3: Passing to Methods [!toc]

**Primitives are passed by value (copy):**

```java
public static void modify(int x) {
    x = 100;  // Changes the parameter, not the original
}

int value = 5;
modify(value);
System.out.println(value);  // Still 5 (unchanged)
```

The method gets a copy. Changing the copy doesn't affect the original.

**References are passed by reference (address):**

```java
public static void modify(ArrayList list) {
    list.add("Item");  // Changes the actual object
}

ArrayList myList = new ArrayList();
modify(myList);
System.out.println(myList.size());  // Size is 1 (it changed!)
```

The method gets the address. Modifications affect the original object.

---

## Variable Naming

Professional Java code follows naming conventions. These aren't rules; they're standards everyone follows.

### camelCase for Variables [!toc]

Variables start with lowercase, then capitalize each new word:

```java
int age = 25;                    // Good
int userAge = 25;                // Good
int user_age = 25;               // Bad (snake_case)
int USER_AGE = 25;               // Bad (UPPER_CASE - reserved for constants)
int a = 25;                      // Bad (unclear - except in obfuscation)
```

### Why Not Use Single Letters? [!toc]

**During development:** Single letters like `a`, `b`, `x` are unclear. Future readers (including future you) won't understand what the variable represents.

```java
int a = 5;          // What is 'a'?
int maxRetries = 5; // Clear
```

**After deployment (Obfuscation):** When you deploy compiled code, obfuscation tools deliberately scramble variable names to `a`, `b`, `c`. This protects intellectual property, decompiled code becomes unreadable.

```
Original source: maxRetries
Compiled .class: a

Hacker decompiles: sees variable 'a', not 'maxRetries'
```

**This isn't a contradiction.** Obfuscation happens _after_ compilation, on the `.class` file. Your source code stays readable and professional. See the [How Java Runs - (How to protect your Java code)](https://wiki.nzar.dev/docs/languages/java/foundations/how-java-runs#understanding-bytecode) section to understand.

### Meaningful Names [!toc]

Use names that describe what the variable contains:

```java
int x = 5;                       // Bad - what is x?
int userAge = 5;                 // Good - clear purpose
int maxAttempts = 5;             // Good - describes the limit
int score = 100;                 // Good - obvious meaning
```

### Boolean Names Often Start with "is", "has", "can" [!toc]

```java
boolean active = true;           // Acceptable
boolean isActive = true;         // Better
boolean hasPassword = false;     // Clear
boolean canDelete = true;        // Clear
boolean isLoggedIn = true;       // Perfect
```

### Array and Collection Names Can Be Plural [!toc]

```java
String[] names = {"Alice", "Bob"};      // Good
int[] scores = {95, 87, 92};            // Good
ArrayList<String> users = new ArrayList(); // Good
```

---

## Constants: Using the `final` Keyword

A constant is a variable that cannot be changed after initialization.

Use the `final` keyword:

```java
final int MAX_ATTEMPTS = 5;
final double PI = 3.14159;
final String APP_NAME = "Calculator";
```

Once set, you cannot change it:

```java
final int MAX_ATTEMPTS = 5;
MAX_ATTEMPTS = 10;  // COMPILE ERROR - cannot change
```

### Naming Conventions for Constants [!toc]

Constants are written in UPPER_CASE with underscores:

```java
final int MAX_USERS = 100;
final String DATABASE_URL = "jdbc:mysql://localhost:3306/mydb";
final double GRAVITY = 9.81;
```

### When to Use Constants [!toc]

**Use constants when:**

1. **Magic numbers appear multiple times**

Instead of:

```java
if (age > 18) { }
if (age > 18) { }
if (age > 18) { }
```

Use:

```java
final int LEGAL_AGE = 18;
if (age > LEGAL_AGE) { }
if (age > LEGAL_AGE) { }
if (age > LEGAL_AGE) { }
```

Now if the legal age changes to 21, you update one line.

2. **Configuration values**

```java
final String API_KEY = "abc123xyz";
final int TIMEOUT_SECONDS = 30;
final double CONVERSION_RATE = 1.2;
```

3. **System limitations**

```java
final int MAX_FILE_SIZE = 10 * 1024 * 1024;  // 10 MB
final int MAX_CONCURRENT_USERS = 1000;
```

**Don't use constants for:**

- Values that truly change (use variables)
- Values that only appear once (unnecessary complexity)

---

## Type Casting: Converting Between Types

Sometimes you need to convert one type to another.

### Automatic Casting (Widening) [!toc]

Converting smaller type to larger type happens automatically:

```java
int age = 25;
long ageLong = age;  // int automatically converts to long (safe)

int number = 5;
double decimal = number;  // int automatically converts to double (safe)
```

Java does this because there's no data loss.

### Manual Casting (Narrowing) [!toc]

Converting larger type to smaller type requires explicit casting:

```java
double price = 99.99;
int roundedPrice = (int) price;  // Manual cast required
System.out.println(roundedPrice);  // 99 (decimal part lost)

long bigNumber = 50000000;
int smallNumber = (int) bigNumber;  // Explicit cast
```

Use the syntax: `(targetType) value`

**Be careful:** Data can be lost when narrowing.

```java
double large = 999999999.99;
int small = (int) large;  // Data loss! Becomes 999999999
```

### String Conversion [!toc]

Converting other types to String:

```java
int age = 25;
String ageString = String.valueOf(age);  // "25"
String ageString = Integer.toString(age);  // Alternative

double price = 19.99;
String priceString = String.valueOf(price);  // "19.99"
```

Or use string concatenation:

```java
int age = 25;
String message = "Age: " + age;  // "Age: 25"
```

---

## Real-World Examples

### Example 1: User Registration [!toc]

```java
public class UserRegistration {
    public static void main(String[] args) {
        // Primitive types
        int userId = 1001;
        int age = 28;
        double accountBalance = 5000.50;
        boolean isPremium = false;

        // Reference types
        String username = "alice_smith";
        String email = "alice@example.com";

        // Constants
        final int MIN_AGE = 18;
        final double INITIAL_BALANCE = 0.0;

        // Validation
        if (age >= MIN_AGE) {
            System.out.println("User " + username + " registered successfully");
            System.out.println("Account balance: $" + accountBalance);
        }
    }
}
```

### Example 2: Working with Collections [!toc]

```java
public class StudentGrades {
    public static void main(String[] args) {
        // Primitive array
        int[] scores = {95, 87, 92, 78};

        // Reference: ArrayList (data structure for flexible storage)
        ArrayList<String> students = new ArrayList();
        students.add("Alice");
        students.add("Bob");
        students.add("Charlie");

        // Constants
        final int PASSING_SCORE = 70;
        final int CLASS_SIZE = students.size();

        // Access
        System.out.println("Class has " + CLASS_SIZE + " students");
        System.out.println("First student: " + students.get(0));
        System.out.println("First score: " + scores[0]);
    }
}
```

---

## Common Bugs and How to Avoid Them

### Bug 1: NullPointerException

```java
String name = null;
System.out.println(name.length());  // CRASH - NullPointerException
```

**Fix:** Check for null first

```java
String name = null;
if (name != null) {
    System.out.println(name.length());  // Safe
}
```

### Bug 2: Modifying Through Reference

```java
ArrayList list1 = new ArrayList();
list1.add("Apple");

ArrayList list2 = list1;  // Both point to same object
list2.add("Banana");

System.out.println(list1);  // ["Apple", "Banana"] - Surprise!
```

**Fix:** Create a new object if you want independent copies

```java
ArrayList list1 = new ArrayList();
list1.add("Apple");

ArrayList list2 = new ArrayList(list1);  // New object with copy
list2.add("Banana");

System.out.println(list1);  // ["Apple"] - unchanged
System.out.println(list2);  // ["Apple", "Banana"]
```

### Bug 3: Type Mismatch

```java
int age = "twenty-five";  // COMPILE ERROR - String to int
```

**Fix:** Use correct types or cast properly

```java
String ageString = "25";
int age = Integer.parseInt(ageString);  // Convert string to int
```

### Bug 4: Integer Overflow

```java
int max = Integer.MAX_VALUE;  // 2,147,483,647
int overflow = max + 1;  // Wraps around to negative!
System.out.println(overflow);  // -2,147,483,648
```

**Fix:** Use `long` for large numbers

```java
long max = Long.MAX_VALUE;
long result = max + 1;  // Safe
```

---

## Why This Matters

- **For memory management:** Understanding primitives vs references helps you write efficient code.
- **For debugging:** Many bugs stem from not understanding reference behavior. You modify one variable and another changes unexpectedly.
- **For performance:** Primitives are faster than objects. Knowing when to use each matters for performance-critical code.
- **For null safety:** Understanding that references can be null prevents crashes.
- **For Java's design:** Static typing prevents entire categories of bugs. This is why enterprise systems trust Java.

---

## Quick Cheat Sheet

### The 8 Primitive Types (Print This!)

```
┌─────────────────────────────────────────┐
│ INTEGERS                                │
├─────────────────────────────────────────┤
│ int age = 25;      ✓ Use this (most)   │
│ long big = 1000L;  ✓ Use for huge nums │
│ short/byte         ✗ Rarely needed     │
├─────────────────────────────────────────┤
│ DECIMALS                                │
├─────────────────────────────────────────┤
│ double price = 19.99;  ✓ Use this      │
│ float small = 5.5f;    ✗ Rarely needed │
├─────────────────────────────────────────┤
│ OTHERS                                  │
├─────────────────────────────────────────┤
│ boolean flag = true;   ✓ True or false │
│ char c = 'A';          ✓ Single char   │
└─────────────────────────────────────────┘
```

### Primitive vs Reference at a Glance

```
┌──────────────────────────────────────────┐
│ PRIMITIVE                                │
├──────────────────────────────────────────┤
│ int x = 5;                              │
│ • Value stored directly in variable     │
│ • Fast (on stack)                       │
│ • Can't be null                         │
│ • Copied by value                       │
│ • int, long, double, float, boolean... │
├──────────────────────────────────────────┤
│ REFERENCE                                │
├──────────────────────────────────────────┤
│ String name = "Alice";                   │
│ • Address stored in variable            │
│ • Slower (on heap)                      │
│ • Can be null                           │
│ • Passed by reference                   │
│ • String, ArrayList, custom classes...  │
└──────────────────────────────────────────┘
```

### Naming Quick Rules

```
Variable names:    myAge, userName, isActive
Constant names:    MAX_USERS, DATABASE_URL, PI
Boolean names:     isActive, hasPassword, canDelete
Array names:       names, scores, users

❌ Bad:            a, x, myVar123, USER_PROFILE
✓ Good:            age, userName, profileData
```

### Memory Quick Facts

```
STACK (Fast)              HEAP (Slower)
├─ Primitives: int, long  ├─ Objects: String
├─ References (addresses) ├─ Arrays: int[]
├─ Automatic cleanup      ├─ Collections: ArrayList
└─ Limited size          └─ Large space
```

### Java vs C/C++ Quick Comparison

```
JAVA                           C/C++
✓ Automatic memory cleanup    ✗ Manual cleanup
✓ No pointer arithmetic       ✗ Complex pointers
✓ Null-safe (mostly)          ✗ Crash-prone
✓ Safer, fewer bugs           ✗ More control
✓ Slower, reliable           ✗ Faster, risky
```

---

## The Key Takeaway

Java has two fundamental data storage mechanisms:

- **References:** Store addresses to objects. Flexible, powerful, but require understanding reference behavior.
- **Primitives:** Store values directly. Fast, simple, predictable. Eight types: `int`, `long`, `double`, `float`, `boolean`, `byte`, `short`, `char`.

Java's **static typing** (declaring types) prevents entire categories of bugs that plague dynamic languages. This isn't a limitation -> it's protection.

Understanding this distinction determines:

- How your data is stored in memory
- How variables behave when passed to methods
- Whether your code creates shared or independent copies
- Why certain bugs happen and how to prevent them
- Why Java is trusted for mission-critical systems

Master this, and you've solved a huge class of bugs before they happen. You'll also understand why Java was designed this way, not as a limitation, but as a feature that keeps systems reliable. <br />

Next up: Operators & Expressions.

---
