---
title: How Java Runs
description: Your first document
icon: FileText
---

---

# How Java Runs: JDK, JVM, JRE, Bytecode [!toc]

## Your First Java Program

You've [installed Java](https://www.geeksforgeeks.org/linux-unix/download-install-java-windows-linux-macos/) and opened your code editor. You write your first program:

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

You save it as `HelloWorld.java`. Now you want to see it run. You open the terminal and type:

```bash
javac HelloWorld.java
```

Something happens. You see a new file appear: `HelloWorld.class`. You don't remember creating it. What just happened?

Then you type:

```bash
java HelloWorld
```

And your program runs. Output: "Hello, World!"

But here's the problem: **You wrote one file (`HelloWorld.java`), but somehow a different file (`HelloWorld.class`) appeared and made things work.**

To fully appreciate this, we need to understand Java's layers. Let us explore what actually happened.

---

## What Just Happened

When you ran those two commands, Java performed two very different operations:

**Step 1: `javac HelloWorld.java`** -> Compilation (writing to bytecode)

**Step 2: `java HelloWorld`** -> Execution (running bytecode)

Most programming languages do this in one invisible step. Java makes it a bit clear. Two separate steps. Two different tools. Two different purposes.

Let's understand what each one does.

---

## Step 1: The Compiler (javac) - Inside the JDK

When you typed `javac HelloWorld.java`, you use the **Java compiler**. I think it's clear that (javac => Java + c => Java + compiler). The compiler is a tool that **comes** from the **JDK (Java Development Kit)**.

**What is the JDK?**

JDK is a toolbox. It's everything you need to write and compile Java code. When you install Java on your computer, you're installing the JDK (if you're developing).

**What's inside this toolbox?**

- **javac** -> The compiler (the tool you just used)
- **java** -> The interpreter/launcher (we'll use this next)
- **javadoc** -> Creates documentation
- **jar** -> Packages your code
- **jdb** -> Debugger for finding bugs
- **Other utilities** -> Various development tools

For now, focus on these two:

- **javac** -> The compiler. Translates Java code to bytecode
- **java** -> The launcher. Runs your bytecode

Other tools (javadoc, jar, jdb, etc.) are useful later, but you don't need them to write and run Java programs. Master the basics first.

**What did javac actually do?**

When you ran `javac HelloWorld.java`, the compiler:

1. Read your `HelloWorld.java` file
2. Checked if your code is syntactically correct (no errors)
3. Translated your human-readable Java code into **bytecode**
4. Wrote the bytecode to a new file: `HelloWorld.class`

That's why the `.class` file appeared. The compiler created it.

**What is bytecode?**

Bytecode is an intermediate language. It's not like Java (humans can **not** easily read it), and it's not machine code (your CPU doesn't understand it too :D). It's something in between, specifically designed for the Java Virtual Machine (JVM) to understand.

Think of it like this:

```
Your Java code: System.out.println("Hello, World!");
     ↓ (javac translates)
Bytecode: GETSTATIC java/lang/System out
          LLOAD 0
          INVOKESPECIAL...
```

It looks weird, but the JVM knows exactly what to do with it.

---

## Step 2: The Java Virtual Machine (JVM) - Inside the JRE

When you typed `java HelloWorld`, you started the **Java Virtual Machine**. The JVM comes from the **JRE (Java Runtime Environment)**.

**What is the JRE?**

JRE is the runtime. It's everything you need to run Java programs. If you just want to use someone else's Java application, you only need the JRE. You don't need the JDK.

**What's inside the JRE?**

- **JVM** - The Java Virtual Machine (the engine)
- **Class libraries** - Pre-written code you can use
- **Other runtime support** - Behind-the-scenes utilities

**What did the JVM actually do?**

When you ran `java HelloWorld`, the JVM:

1. Looked for the `HelloWorld.class` file (bytecode)
2. Read the bytecode inside it
3. Translated the bytecode to machine code specific to your operating system (Windows/Mac/Linux)
4. Executed the machine code on your computer
5. Printed: "Hello, World!"

This is the magic moment. The same `HelloWorld.class` file can run on Windows, Mac, or Linux. The JVM on each platform does the translation.

---

## Why Two Steps? Why Not Just One?

This is where Java's genius reveals itself.

**In C++:**

```
Write C++ code → Compile to Windows machine code
Write C++ code → Compile to Mac machine code
Write C++ code → Compile to Linux machine code

If you want your program on three platforms, you compile three times.
```

**In Java:**

```
Write Java code → Compile once to bytecode
                ↓
        Bytecode is platform-independent
                ↓
        [JVM on Windows] → Runs
        [JVM on Mac] → Runs
        [JVM on Linux] → Runs

You compile once. The bytecode runs everywhere.
```

The bytecode acts as a universal middle language. It's the same whether you're on Windows, Mac, or Linux. The JVM translates it to whatever machine code is needed for that specific platform.

---

## The Three Layers Explained

### Layer 1: JDK (Java Development Kit) - For Developers

**What:** The toolbox for writing and compiling Java code.

**When you use it:** During development, when you're writing code and need to compile it.

**Key tool:** `javac` (the compiler)

**Example:**

```bash
javac MyProgram.java    # Uses JDK to compile
# Creates MyProgram.class (bytecode)
```

**Important:** If you're developing Java, install JDK. That's it. JDK includes everything you need because it includes the JRE inside it.

---

### Layer 2: JRE (Java Runtime Environment) - For Running Programs

**What:** The runtime for executing Java programs.

**When you use it:** When you want to run a Java program (yours or someone else's).

**Key tool:** `java` (the launcher/interpreter)

**Example:**

```bash
java MyProgram    # Uses JRE to run bytecode
# Executes the program
```

**Important:** If you just want to use Java applications, you only need the JRE. You don't need the compilation tools.

**Relationship:**

```
JDK = Compiler + Debugger + Tools + JRE
JRE = JVM + Class Libraries + Runtime Support
```

So JDK includes JRE. If you have JDK, you have everything.

---

### Layer 3: JVM (Java Virtual Machine) - The Engine

**What:** The software that actually runs your bytecode.

**When you use it:** Indirectly, whenever you run a Java program with `java`.

**What it does:**

1. Reads bytecode (.class files)
2. Translates bytecode to machine code for your platform
3. Executes the machine code

**The revolutionary part:** The JVM is different for each platform (Windows JVM, Mac JVM, Linux JVM), but they all understand the same bytecode. This is why Java code is truly portable.

```
Same bytecode everywhere ✓
Different JVM for each platform ✓
Result: Write Once, Run Anywhere ✓
```

**Is the JVM slow?**

Not anymore. Modern JVMs use JIT (Just-In-Time) compilation. They translate frequently-used bytecode to optimized machine code while the program runs. Java can actually be faster than C++ for some workloads because the JVM optimizes based on real usage patterns.

---

## Understanding Bytecode

Let's go back to that mysterious `.class` file. It contains bytecode. You don't write bytecode, the compiler creates it. But understanding what it is helps you understand Java.

**What is bytecode exactly?**

Bytecode is an instruction set designed for the JVM. Each instruction does something simple:

- Load a variable
- Call a method
- Compare two values
- Jump to a different part of the code

**Example:** Your Java line:

```java
System.out.println("Hello, World!");
```

Becomes bytecode instructions like:

```
GETSTATIC java/lang/System.out
LDC "Hello, World!"
INVOKEVIRTUAL java/io/PrintStream.println
```

The JVM reads these instructions and translates them to real machine code.

**Bytecode vs Assembly**

People ask: "Is bytecode like assembly?"

Yes and no. Similar concept, but different purposes:

| Assembly                                | Bytecode                                          |
| --------------------------------------- | ------------------------------------------------- |
| Written for a specific CPU (Intel, ARM) | Written for the JVM (platform-independent)        |
| Very low-level instructions             | Higher-level instructions                         |
| Runs directly on hardware               | Runs on the JVM, which translates to machine code |

**Can bytecode be reverse-engineered?**

Yes. Bytecode is readable (though difficult). This is intentional, the JVM verifies bytecode before running it for security. But it means theoretically someone could decompile your `.class` files back to source code. That's why developers sometimes scramble code to protect it.

<Card>
  Note: bytecode wasn't invented by Java, but Java made it practical and
  mainstream. Other languages had similar ideas (Smalltalk, LISP), but Java's
  implementation was clean, efficient, and timed perfectly with the internet
  boom.
</Card>

---

## The Complete Journey Visualized

Here's your code's complete journey:

```
You write: HelloWorld.java

        ↓ (You run: javac HelloWorld.java)

   [JDK Compiler]
   (javac tool)

        ↓ (Creates)

HelloWorld.class (bytecode)

        ↓ (You run: java HelloWorld)

   [JVM - Java Virtual Machine]
   (Reads bytecode)
   (Translates to machine code)
   (Executes)

        ↓ (Output)

"Hello, World!"
```

This entire process takes milliseconds. But understanding each step is what makes you a real Java developer.

---

## Why This Matters

**For writing code:** You need to know that `javac` compiles and `java` runs. You can't run code that hasn't been compiled.

**For debugging:** If your code compiles but crashes, it's a runtime issue (JVM/JRE problem). If it won't compile, it's a compilation issue (JDK/syntax problem). Understanding the difference speeds up debugging.

**For deployment:** You only need to send `.class` files (or packaged `.jar` files), not source code. Users just need the JRE to run your program.

**For performance:** The JVM's bytecode allows runtime optimization. This is why Java can be very efficient despite the extra abstraction layer.

**For portability:** Your bytecode runs the same on Windows, Mac, and Linux. This is Java's superpower.

---

## Common Practical Questions

**What happens if I don't have the JRE installed?**

You can't run Java programs. You get an error: "java: command not found." Users of your program need the JRE installed.

**Can I send someone just the `.class` file?**

Yes. Send them the `.class` file, they run `java ClassName` and it works (as long as they have JRE installed). They don't see your source code.

**Why do `.class` files look like gibberish?**

Because they contain bytecode, which is designed for machines, not humans. This is intentional. The JVM needs to parse it quickly and efficiently.

**Is Java always slower than C++?**

No. Modern JVMs can be as fast or faster than C++ for many workloads. The bytecode → machine code translation happens with sophisticated optimization. C++ is fast by default, Java optimizes as it runs.

---

## In Summary

Java's magic is this two-step process:

1. **Compile once to bytecode** - Platform-independent
2. **JVM translates to machine code** - Platform-specific

This separation of concerns is why Java code truly runs anywhere. The compiler doesn't need to know about your operating system. The JVM handles platform differences.

Understanding JDK, JRE, and JVM isn't just theory. It's the foundation for everything else: frameworks, deployment, debugging, performance tuning. You now know what's actually happening when you write and run Java code.

That's real understanding.

---
